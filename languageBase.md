



## Access Level

![img](https://images2015.cnblogs.com/blog/690292/201609/690292-20160923095944481-1758567758.png)

注意：java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。





## Interpreted Language & Complied Language

解释型语言和编译型语言的区别

首先，我们编程都是用的高级语言(写汇编和机器语言的大牛们除外)，计算机不能直接理解高级语言，只能理解和运行机器语言，所以必须要把高级语言翻译成机器语言，计算机才能运行高级语言所编写的程序。

   说到翻译，其实翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同。

   用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统（不仅仅只是通过编译器，编译器只是编译系统的一部分）把高级语言翻译成机器语言（具体翻译过程可以参看下图），把源高级程序编译成为机器语言文件，比如windows下的exe文件。以后就可以直接运行而不需要编译了，因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高，但也不能一概而论，部分解释型语言的解释器通过在运行时动态优化代码，甚至能够使解释型语言的性能超过编译型语言。

  ![图示  描述已自动生成](file:////Users/dyq/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image001.png)

  一个完整的编译系统与 一个用C编写的程序hello.c的编译过程 

   解释则不同，解释型语言编写的程序不需要编译。解释型语言在运行的时候才翻译，比如VB语言，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言，每个语句都是执行的时候才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。

   编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/Object Pascal（Delphi）等都是编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如JavaScript、VBScript、Perl、Python、Ruby、MATLAB 等等。

   但随着硬件的升级和设计思想的变革，编译型和解释型语言越来越笼统，主要体现在一些新兴的高级语言上，而解释型语言的自身特点也使得编译器厂商愿意花费更多成本来优化解释器，解释型语言性能超过编译型语言也是必然的。

   说到这里，我们有必要说一下java与C#。解释型语言和编译型语言的区别

   JAVA语言是一种编译型-解释型语言，同时具备编译特性和解释特性（其实，确切的说java就是解释型语言，其所谓的编译过程只是将.java文件编程成平台无关的字节码.class文件，并不是向C一样编译成可执行的机器语言，在此请读者注意Java中所谓的“编译”和传统的“编译”的区别）。作为编译型语言，JAVA程序要被统一编译成字节码文件——文件后缀是class。此种文件在java中又称为类文件。java类文件不能再计算机上直接执行，它需要被java虚拟机翻译成本地的机器码后才能执行，而java虚拟机的翻译过程则是解释性的。java字节码文件首先被加载到计算机内存中，然后读出一条指令，翻译一条指令，执行一条指令，该过程被称为java语言的解释执行，是由java虚拟机完成的。而在现实中，java开发工具JDK提供了两个很重要的命令来完成上面的编译和解释（翻译）过程。两个命令分别是java.exe和javac.exe，前者加载java类文件，并逐步对字节码文件进行编译，而另一个命令则对应了java语言的解释(javac.exe)过程。在次序上，java语言是要先进行编译的过程，接着解释执行。

  C#语言是编译型语言，但其“编译”过程比较特殊，具体说明如下：

  C#程序在第一次运行的时候，会依赖其.NET Frameworker平台，编译成IL中间码），然后由JIT compiler翻译成本地的机器码执行。从第二次在运行相同的程序，则不需要再执行以上编译和翻译过程，而是直接运行第一次翻译成的机器码。所以对于C#来说，通常第一次运行时间会很长，但从第二次开始，程序的执行时间会快很多。

  那么，C#为什么要进行两次“编译”呢？其实，微软想通过动态编译（由JIT compiler工具实现）来实现其程序运行的最优化。如果代码在运行前进行动态编译运行，那么JIT compiler可以很智能的根据你本地机器的硬件条件来进行优化，比如使用更好的register,机器指令等等，而不是像原来那样，build一份程序针对所有硬件的机器跑，没有充分利用各个机器的条件。

  另外，还有我们经常用到的脚本语言，比如JavaScript、Shell等语言都是脚本语言，本质上来说，脚本语言就是解释型语言。

 

简化版的过程图示：![img](file:////Users/dyq/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image002.png)

![img](file:////Users/dyq/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image003.png)

一、编译执行和解释执行的一些基本概念：

 

JVM：一种能够运行Java字节码（Java bytecode）的虚拟机。（下面有更具体的JVM的内容）

 

字节码：字节码是已经经过编译（.class文件），但与特定机器码无关，需要解释器转译后才能成为机器码的中间代码。

 

Java字节码：是Java虚拟机执行的一种指令格式。

 

解释器：是一种电脑程序，能够把高级编程语言一行一行直接翻译运行。解释器不会一次把整个程序翻译出来，只像一位“中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每翻译一行程序叙述就立刻运行，然后再翻译下一行，再运行，如此不停地进行下去。它会先将源码翻译成另一种语言，以供多次运行而无需再经编译。其制成品无需依赖编译器而运行，程序运行速度比较快。

 

二进制文件：广义的二进制文件即为文件，由文件在外部存储设备的存放方式为二进制而得名。狭义的二进制文件即指除文本文件以外的文件。文本文件的格式包括：ASCII、MIME、txt。

 

Java编译器：将Java源文件（.java文件）编译成字节码文件（.class文件，是特殊的二进制文件，二进制字节码文件），这种字节码就是JVM的“机器语言”。javac.exe可以简单看成是Java编译器。

 

JIT编译器（注意与Java解释器区分）：JIT编译器是JRE的一部分。原本的Java程序都是要经过解释执行的，其执行速度肯定比可执行的二进制字节码程序慢。为了提高执行速度，引入了JIT。在运行时，JIT会把翻译过来的机器码保存起来，以备下次使用。而如果JIT对每条字节码都进行编译，则会负担过重，所以，JIT只会对经常执行的字节码进行编译，如循环，高频度使用的方法等。它会以整个方法为单位，一次性将整个方法的字节码编译为本地机器码，然后直接运行编译后的机器码。

即时编译(Just-in-time compilation: JIT)：又叫实时编译、及时编译。是指一种在运行时期把字节码编译成原生机器码的技术，一句一句翻译源代码，但是会将翻译过的代码缓存起来以降低性能耗损。这项技术是被用来改善虚拟机的性能的。

 

JVM:JVM有自己完善的硬件架构，如处理器、堆栈（Stack）、寄存器等，还具有相应的指令系统（字节码就是一种指令格式）。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。JVM是Java平台无关的基础。JVM负责运行字节码：JVM把每一条要执行的字节码交给解释器，翻译成对应的机器码，然后由解释器执行。JVM解释执行字节码文件就是JVM操作Java解释器进行解释执行字节码文件的过程。（还有JIT的作用）

 

注意：通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作，因为此可执行文件包含了对目标处理器的机器语言。而Class文件这种特殊的二进制文件，是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的！

 

二、Java编译执行和解释执行的意义

HotSpot VM是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。

但是如今的HotSpot VM中不仅内置有解释器，还内置有先进的JIT（Just In Time Compiler）编译器，在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短。有一点需要注意，无论是采用解释器进行解释执行，还是采用即时编译器进行编译执行，最终字节码都需要被转换为对应平台的本地机器指令。

 

问：既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？

对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。

 

由于即时编译器将本地机器指令的编译推迟到了运行时，自此Java程序的运行性能已经达到了可以和C/C++程序一较高下的地步。这主要是因为JIT编译器可以针对那些频繁被调用的“热点代码”做出深度优化，而静态编译器的代码优化则无法完全推断出运行时热点，因此通过JIT编译器编译的本地机器指令比直接生成的本地机器指令拥有更高的执行效率也就理所当然了。

 

 

 

三、具体流程图:

![img](file:////Users/dyq/Library/Group%20Containers/UBF8T346G9.Office/TemporaryItems/msohtmlclip/clip_image004.png)

 

如果看不清的话，这里有PDF版本的https://pan.baidu.com/s/1DyU7edvAOJq_7VGVfEzPfA

 

以上为个人学习笔记，如存在错误，还请大家多多指教！

————————————————

版权声明：本文为CSDN博主「沉晓」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/qq_42322103/article/details/88038677
